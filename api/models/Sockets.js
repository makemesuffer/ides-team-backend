module.exports = {

    attributes: {
        socketId: {
            // The probabilistically unique ID of the socket connection which
            // this record represents.  This is generated by Socket.io when the
            // socket initially connects
            type: 'string',
            required: true,
            unique: true
        },
        accountId: {
            type: 'string'
        },
        clientMark: {
            type: 'string'
        },
        institutionId: {
            type: 'string'
        },
        profileType: {
            type: 'string'
        },
        rooms: {
            type: 'json',
            defaultsTo: []
        },
        // optional obj of extra data
        additionalInfo: {
            type: 'json',
            defaultsTo: {}
        }
    },

    broadcast: (rooms, matter, data) => {
        sails.sockets.broadcast(rooms, matter, { ...data })
    },

    makeRoomName: (...params) => params.join(':'),

    getSocketRooms: async (socketId) => {
        try {
            const socket = await Sockets.findOne({ socketId })
            if (!socket) return { success: false, reason: 'noSuchSocket' }

            return { success: true, reason: socket.rooms }
        } catch (e) {
            return { success: false, reason: e }
        }
    },

    join: async (socketId, room, recordData) => {
        try {
            const result = await new Promise(async (resolve, reject) => {
                const socket = await Sockets.findOne({ socketId })

                if (socket && socket.rooms.includes(room)) {
                    return resolve(`socket ${socketId} has alrady been subscribed to ${room}`)
                }

                if (socket && !socket.rooms.includes(room)) {
                    return sails.sockets.join(socketId, room, async (err) => {
                        if (err) return reject(err)

                        const updated = await Sockets.update({ socketId }, { rooms: [...socket.rooms, room] }) || []
                        return resolve(updated[0])
                    })
                }

                sails.sockets.join(socketId, room, async (err) => {
                    if (err) return reject(err)

                    const created = await Sockets.create({ socketId, rooms: [room], ...recordData })
                    return resolve(created)
                })
            })

            return { success: true, reason: result }
        } catch (e) {
            return { success: false, reason: e }
        }
    },

    leave: async (socketId, room) => {
        try {
            const result = await new Promise((resolve, reject) => {
                sails.sockets.leave(socketId, room, async (err) => {
                    if (err) return reject(err)
                    const socket = await Sockets.findOne({ socketId })

                    if (socket) {
                        socket.rooms = socket.rooms.filter(i => i !== room)

                        if (socket.rooms.length) {
                            const result = await Sockets.update({ socketId }, { rooms: socket.rooms }) || []
                            return resolve(result[0])
                        }

                        const result = await Sockets.destroy({ socketId }) || []
                        return resolve(result[0])
                    }

                    return reject(new Error('no such socket'))
                })
            })

            return { success: true, reason: result }
        } catch (e) {
            return { success: false, reason: e }
        }
    },

    leaveAll: async (socketId) => {
        try {
            const { success, reason: rooms } = await Sockets.getSocketRooms(socketId)
            if (success && rooms.length) await Promise.all(rooms.map(r => Sockets.leave(socketId, r)))

            return { success: true }
        } catch (e) {
            return { success: false, reason: e }
        }
    },

    getRoomMembers: async (room) => {
        try {
            const members = await NativeQuery.find(Sockets, { rooms: { $in: [room] } })
            return { success: true, reason: members }
        } catch (e) {
            return { success: false, reason: e }
        }
    },

    maintain: async () => {
        try {
            const sockets = await Sockets.find({}) || []

            const aliveSockets = Object.keys(sails.io.sockets.sockets)
            const deadSockets = sockets.filter(s => !aliveSockets.includes(s.socketId)).map(s => s.socketId)

            await Promise.all(deadSockets.map(s => Sockets.destroy({ socketId: s })))
            return { success: true }
        } catch (e) {
            return { success: false, reason: e }
        }
    }

}
